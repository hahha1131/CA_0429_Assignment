## 정렬 알고리즘  

___

### To do  

* 입력 데이터는  
~~~
[32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16348, 32768, 65536, 131072, 262144, 524288, 1048576]
~~~
* 세 가지 경우에 대해 알고리즘 수행 시간 측정하여 그래프로 표현  
   * 정렬된 데이터(위의 배열 그대로 입력)  
   * 랜덤 데이터(위의 배열에서 인덱스와 원소 값 무작위 재배치)  
   * 역 정렬 데이터(배열 원소를 역으로 배치)  
___

### 버블 정렬  

* 이웃하는 숫자와 비교하며 오름차순 또는 내림차순으로 정렬하는 알고리즘  

#### 버블 정렬 성능 분석
 **(정렬된 데이터의 시간복잡도 계산)**  
* 이중 for문이 실행된다  
* 위 배열의 크기는 인덱스로 0~15(총 크기는 16)이므로 비교 횟수는 16 * 15 / 2 = 120(회) {n(n-1)/2}  
* 안쪽 for문의 if문이 참이라면 자리가 바뀌지 않기 때문에 O(1) 시간 경과  
* 최종 시간복잡도는 O(n^2) * O(1) = O(n^2)  

 **(정렬된 데이터의 비교 횟수와 교체 횟수)**  
* 정렬이 되어 있기에, 비교는 수행하지만 교체는 일어나지 않음
* 따라서 비교 횟수는 120회, 교체 횟수는 0회

 **(랜덤 데이터 시간복잡도 계산) **  
* 버블 정렬의 작동 방식과 수행하는 데에 걸리는 시간은, 배열의 비교 횟수와 교체 횟수에 관계없이 최악의 경우에서의 복잡도인 O(n^2)  

 **(랜덤 데이터의 비교 횟수와 교체 횟수)**  
* 만약 랜덤으로 배열을 섞은 결과가 다음과 같다면

~~~
[64, 32, 512, 256, 5128, 1024, 2048, 131027, 1048576, 262144, 32768, 65536, 4096, 16348, 524288, 8192]
~~~
* 비교 횟수는 동일하게 120회  
* 교체 횟수는 30회  

 **(역 정렬 데이터의 시간복잡도)**  
* 역시나 O(n^2)  

 **(역 정렬 데이터의 비교 횟수와 교체 횟수)**  
* 비교 횟수 120회  
* 교체 횟수는 120회  

___

### 선택 정렬  

* 입력된 데이터 중 가장 작은 데이터를 선택하여 배열의 앞으로 이동시키는 알고리즘  

#### 선택 정렬 성능 분석  
 **(정렬된 데이터의 시간복잡도 계산)**  
* 버블 정렬과 같이 두 개의 for문, 내부 for문의 if문(최솟값인지 확인하는 if문)이 참이면 교체 X  
* 따라서, 비교 횟수는 버블 정렬과 동일하게 n(n-1)/2 이므로, 16 * 15 / 2 = 120(회)  
* 정렬이 되어 있기 때문에 교체하는 과정의 시간복잡도는 O(1)  
* 최종 시간복잡도는 O(n^2)  

 **(정렬된 데이터의 비교 횟수와 교체 횟수)**  
* 비교 횟수는 120회  
* 교체 횟수는 0회  

 **(랜덤한 데이터의 시간복잡도 계산)**  
* 각 정렬의 시간복잡도는 최악의 경우에서 도출되는 시간복잡도이기 때문에 데이터의 입력 순서에 상관없이 O(n^2)  

 **(랜덤한 데이터의 비교 횟수와 교체 횟수)**  
* 비교 횟수는 120회  
* 교체 횟수는 8회  

 **(역 정렬 데이터의 시간복잡도)**  
* 위에서 언급한 것과 같이 O(n^2)  

 **(역 정렬 데이터의 비교 횟수와 교체 횟수)**  
* 비교 횟수 120회  
* 교체 횟수 8회  

___
